<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 2 Write-Up</h1>
		<div style="text-align: center;">Names: Isabella Alpert & Robert Nochez </div>

		<br>

		Link to webpage: <a href=https://cal-cs184-student.github.io/hw-webpages-top-dog-enjoyers-1/hw2/index.html>cs184.eecs.berkeley.edu/sp25/hw2</a>

		<br>
		
		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/sp25-hw2-woopers-woops">github.com/sp25/hw2</a>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Section I: Bezier Curves and Surfaces</h2>

		<h3>Part 1: Bezier curves with 1D de Casteljau subdivision</h3>
		
		<p>
			De Casteljau's algorithm is a recursive algorithm that is used to evaluate polynomials via liner intepolation. More 
			specifically, it can be used to evaluate Bezier curves. We implemented it in the <code>evaluateStep()</code> method by first 
			creating a 2D Vector to store our new intermediary points. Then, we used a for loop, starting at 0 and looping up to 
			<code>points.size() - 1</code> times. This ensures we are working on one less point with each recursive call, allowing us to 
			eventually converge at a singular point. For each pair of adjacent points in the for loop and a given parameter <code>t</code>, 
			we find the linear interpolation of the two points using \( (1 - t) \cdot p_i + t \cdot p_{i+1} \). We then add this point to our 2D Vector.
			Once the for loop has terminated, we return our vector. By pressing <code>E</code> in our GUI, we step along each call of our 
			recursive function. Once pressing <code>E</code> causes the red point to appear, we have reached our base case and evaluated our
			Bezier curve at a single point.
		</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="task1_step0.png" width="400px"/>
				  <figcaption>Step 0</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="task1_step1.png" width="400px"/>
				  <figcaption>Step 1</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="task1_step2.png" width="400px"/>
				  <figcaption>Step 2</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="task1_step3.png" width="400px"/>
				  <figcaption>Step 3</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="task1_step4.png" width="400px"/>
				  <figcaption>Step 4 - Displays Evaluated Point</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<figure>
			<img src="task1_newCurve.png" alt="New Curve" style="width:50%"/>
			<figcaption>Bezier Curve with New Control Points and New t</figcaption>
		</figure>

		<h3>Part 2: Bezier surfaces with separable 1D de Casteljau</h3>
		
		<p>
			De Casteljau's algorithm applies to Bezier surfaces because instead of working along a one dimensional curve, we are 
			now working along a two dimensional surface. We accomplish this by using de Casteljau's algorithm twice; first along 
			<code>u</code> as one of our parameters and then along <code>t</code> as our other parameter. For this task, we
			implemented de Casteljau's algorithm by applying the algorithm (using the <code>evaluate1D()</code> method) for each row 
			of our <code>n x n</code> control points with parameter <code>u</code>. Each point is added to a Vector3D. After we 
			finish evaluating each row, we then evaluate the Vector3D with parameter <code>v</code> using <code>evaluate1D()</code>.
			<code>evaluate1D()</code> works by taking a vector of points and a parameter and calling <code>evaluateStep()</code> until
			we are left with our final, interpolated point that was represented by the red point in Task 1. 
		</p>

		<figure>
			<img src="task2_teapot.png" alt="Mesh Teapot" style="width:50%"/>
			<figcaption>Teapot Generated by Bezier Surface</figcaption>
		</figure>

		<h2>Section II: Triangle Meshes and Half-Edge Data Structure</h2>

		<h3>Part 3: Area-weighted vertex normals</h3>
		
		<p>
			For this task, we implemented area-weighted vertex normals by first defining our variables: <code>HalfedgeCIter 
			heCIter = halfedge()</code>, <code>HalfedgeCIter start = halfedge()</code>, and <code>Vector3D norUnitVec(0, 0, 0)</code>.
			Then, we run a do-while loop with the conditional <code>heCIter != start</code>, meaning that we will continue to loop until
			we have traversed the entire mesh and end up at our original, starting halfedge. Next, we find the three vertices associated with
			a face using the <code>vertex()</code>, <code>next()</code>, and <code>position</code> methods and variables associated with the
			halfedge class. Once we have all three vertices, we know that the normal of a face is defined by the vector that is perpendicular
			to the surface, so we can find the cross product of these two vectors to receive the third, normal vector. We implemented this step 
			by defining the vectors as <code>vertex3 - vertex1</code> and <code>vertex3 - vertex2</code> and finding the cross product of these
			vectors using the <code>cross()</code> method. We then add the normal vector to our <code>norUnitVec</code> variable. We iterate 
			to the next halfedge using <code>heCIter = heCIter->twin()->next()</code>, giving us the a new halfedge on an adjacent face.
		</p>

		<p>
			The screenshots below show the difference between default flat shading and phong shading (which we implemented by using
			area-weighted vertex normals). As we can clearly see, the phong shading is much smoother, where as the default flat shading
			has different colors contained to each face, making the image look blockier and the shading less smooth.
		</p>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="task3_flat.png" width="400px"/>
				  <figcaption>Teapot with Default Flat Shading</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="task3_phong.png" width="400px"/>
				  <figcaption>Teapot with Phong Shading</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h3>Part 4: Edge flip</h3>
		
		<p>
			For this task, the way we implemented edge flips was first having a conditional that checks if the two faces that
			are adjacent to the passed in edge are not on the boundary. If they are, we do not perform an edge flip and return
			<code>e0</code>. If they are not on the boundary, we then store the six half edges that make up the two
			triangles of the edge we want to flip. Note that one of these halfedges is the twin of <code>e0</code>.
			Next, we store the two associated faces, four associated edges (not including <code>e0</code>), and four
			associated vertices. Afterwards, we use <code>setNeighbors()</code> to reset the associated <code>next</code>,
			<code>twin</code>, <code>vertex</code>, <code>edge</code>, and <code>face</code> for each of our six halfedges. We 
			need to do this because as we flip the edges, the relationship between these different parameters of a halfedge change
			and we need to update them accordingly. After we've updated the parameters of each halfedge, we need to update the 
			parameters of the two faces and the four vertices to make sure that they are associated with the correct halfedges
			after the edge flip occurs. Finally, we returned <code>e0</code>. An interesting implentation trick that we 
			used was making sure that we stored all relevant pointers, even if they didn't need to be updated. For example, we 
			stored all four edges in their own variables, even though we could have referenced them through pointers via the 
			haldedges. This helped us make sure that we weren't making any minor mistakes when referencing these variables later
			on. This ties into a helpful debugging tip; by explicitly storing our variables, it was easier to understand what was
			occurring at each step as opposed to getting confused between different pointers.
		</p>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="task4_normalTeapot.png" width="400px"/>
				  <figcaption>Teapot with No Flipped Edges</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="task4_flippedTeapot.png" width="400px"/>
				  <figcaption>Teapot with Non-Adjacent Edge Flips</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="task4_moreFlips.png" width="400px"/>
				  <figcaption>Teapot with More & Adjacent Edge Flips (Angle 1)</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="task4_newAngle.png" width="400px"/>
				  <figcaption>Teapot with More & Adjacent Edge Flips (Angle 2)</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<p>
			The debugging for this task was arduous! At first, whenever we flipped an edge, we would create a hole in our
			mesh. We knew that this was caused by a misplaced pointer, but with so many pointers, it was hard to determined 
			exactly what went wrong. We first started debugging by drawing out the edge flip. Drawing the 
			edge flip and explicitly labeling each relevant part made it easier for us to go through our code and make sure 
			that our pointers matched up. While this helped our understanding of the task, it did not resolve the error. Thus,
			our next debugging step was to be more deliberate in how we were defining our variables. Previously, we defined variables
			using other variables. For example, we had <code>HalfedgeCIter he1 = e0->halfedge()</code> and 
			<code> HalfedgeCIter he2 = he1->twin()</code>. While this definitely would have worked, we found it difficult to tell
			if our variables were storing the correct information. To counteract this, we stored everything relevant to
			<code>e0</code>, <code>he1</code>, and <code>he2</code>. Through these two methods, we were able to find 
			inconsistencies in our pointers, allowing us to eventually debug this method.
		</p>

		<h3>Part 5: Edge split</h3>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h3>Part 6: Loop subdivision for mesh upsampling</h3>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
		
		</div>
	</body>
</html>